//
// Copyright(C) 2005--2011 FirteX Development Team. 
// All rights reserved.
// This file is part of FirteX (http://sourceforge.net/projects/firtex)
//
// Use of the FirteX is subject to the terms of the software license set forth in 
// the LICENSE file included with this software.
//
// Author  : Ruijie Guo
// Email   : ruijieguo@gmail.com
// Created : 2012-02-16 22:03:40

#ifndef __FX_ZKCLIENTWRAPPER_H
#define __FX_ZKCLIENTWRAPPER_H

#include "firtex/common/StdHeader.h"
#include "firtex/common/Logger.h"
#include "firtex/common/SharedPtr.h"
#include "firtex/utility/NonCopyable.h"
#include "firtex/thread/RWLock.h"
#include "firtex/extension/network/FunctionBinder.h"
#include <zookeeper.h>
#include <atomic>


FX_NS_DEF(common);

class ZkClientWrapper : public FX_NS(utility)::NonCopyable
{
public:
    typedef int32_t watcherid_t;
    const static watcherid_t INVALID_WATCHERID = -1;

    typedef int state_t;
    const static state_t ZK_INVALID_STATE = -1;
    const static state_t ZK_EXPIRED_SESSION_STATE = 0;
    const static state_t ZK_AUTH_FAILED_STATE = 1;
    const static state_t ZK_CONNECTING_STATE = 2;
    const static state_t ZK_ASSOCIATING_STATE = 3;
    const static state_t ZK_CONNECTED_STATE = 4;

    typedef int event_t;

    /**
     * \brief invalid event
     */
    const static event_t ZK_INVALID_EVENT = -1;

    /**
     * \brief a node has been created.
     * 
     * This is only generated by watches on non-existent nodes. 
     * These watches are set using \ref exists().
     */
    const static event_t ZK_CREATED_EVENT = 0;
        
    /**
     * \brief a node has been deleted.
     * 
     * This is only generated by watches on nodes. These watches
     * are set using \ref exists() and \ref readData().
     */
    const static event_t ZK_DELETED_EVENT = 1;

    /**
     * \brief a node has changed.
     * 
     * This is only generated by watches on nodes. These watches
     * are set using \ref exists() and \ref readData().
     */
    const static event_t ZK_CHANGED_EVENT = 2;

    /**
     * \brief a change as occurred in the list of children.
     * 
     * This is only generated by watches on the child list of a node. These watches
     * are set using \ref subscribeChildChanges()
     */
    const static event_t ZK_CHILD_EVENT = 3;
        
    /**
     * \brief a session has been lost.
     * 
     * This is generated when a client loses contact or reconnects with a server.
     */
    const static event_t ZK_SESSION_EVENT = 4;

    /**
     * \brief a watch has been removed.
     * 
     * This is generated when the server for some reason, probably a resource
     * constraint, will no longer watch a node for a client.
     */
    const static event_t ZK_NOTWATCHING_EVENT = 5;

    struct Context
    {
        Context(ZkClientWrapper* c, state_t s, event_t e)
            : client(c), state(s), event(e)
        {
        }

        ZkClientWrapper* client;
        state_t state;
        event_t event;
    };

    /// Function called after specified event occurred
    DECLARE_CLASS_AND_BINDER2(EventHandler, const std::string&, const Context&);
    
    DEFINE_TYPED_PTR(EventHandler);

public:
    typedef std::map<watcherid_t, EventHandlerPtr> ListenerMap;
    DEFINE_TYPED_PTR(ListenerMap);

    typedef std::map<std::string, ListenerMapPtr> ListenersMap;

public:
    ZkClientWrapper();
    ~ZkClientWrapper();

public:
    /**
     * Connect to zookeeper server
     *
     * @param sHost zookeeper server address
     * @param nRecvTimeout receive timeout
     * @return true if connection is ok
     */
    bool connect(const std::string& sHost, int32_t nRecvTimeout = 10000);

    /**
     * Close the connection to zookeeper server
     */
    void close();

    /**
     * Return true if the connection to zookeeper server is ok 
     */
    bool isConnected() const;

    /**
     * Return true if in connecting state
     */
    bool isConnecting() const;

    /**
     * Return true if something is bad
     */
    bool isBad() const;

public:
    /**
     * Subscribe child change event
     *
     * @param sPath node's path
     * @param pChildListener event handler, this class take the ownership
     * @param children return the children
     * @return valid watcher id if success, otherwise return INVALID_WATCHERID
     */
    watcherid_t subscribeChildChanges(const std::string& sPath,
            EventHandler* pChildListener, std::vector<std::string>& children);

    /**
     * Unsubscribe child change event
     *
     * @param sPath node's path
     * @param wid watcher id returned by \ref subscribeChildChanges()
     * @return true if success, otherwise return false
     */    
    bool unsubscribeChildChanges(const std::string& sPath,
                                 watcherid_t wid);

    /**
     * Subscribe data change event
     *
     * @param sPath node's path
     * @param pDataListener event handler, this class take the ownership
     * @param children return the children
     * @return valid watcher id if success, otherwise return INVALID_WATCHERID
     */
    watcherid_t subscribeDataChanges(const std::string& sPath,
            EventHandler* pDataListener);

    /**
     * Unsubscribe data change event
     *
     * @param sPath node's path
     * @param wid watcher id returned by \ref subscribeDataChanges()
     * @return true if success, otherwise return false
     */    
    bool unsubscribeDataChanges(const std::string& sPath, 
                                watcherid_t wid);

    /**
     * Unsubscribe all watcher event
     */
    void unsubscribeAll();

    /**
     * Create a persistent node.
     * 
     * @param sPath
     * @param sData
     * @return true if success, otherwise return false
     */
    bool createPersistent(const std::string& sPath, 
                          const std::string& sData);

    /**
     * Create a persistent, sequental node.
     * 
     * @param sPath node's path
     * @param sData node's data
     * @return create node's path
     */
    bool createPersistentSequential(const std::string& sPath,
                                    const std::string& sData, 
                                    std::string& sResultPath);

    /**
     * Create an ephemeral node.
     * 
     * @param sPath node's path
     */
    bool createEphemeral(const std::string& sPath);

    /**
     * Create an ephemeral node.
     * 
     * @param sPath node's path
     * @param sData node's data
     */
    bool createEphemeral(const std::string& sPath, 
                         const std::string& sData);
                              
    /**
     * Create an ephemeral, sequential node.
     * 
     * @param sPath node's path
     * @param sData node's data
     * @return created path
     */
    std::string createEphemeralSequential(const std::string& sPath,
            const std::string& sData);

    /**
     * Counts number of children for the given path.
     * 
     * @param sPath node's path
     * @return number of children or 0 if path does not exist.
     */
    size_t countChildren(const std::string& sPath);

    /**
     * Check existence of node
     *
     * @param sPath node's path
     * @param bWatch set data change watcher on it or not
     * @param bExist set true if the node exists
     * @return return true if success
     */
    bool exists(const std::string& sPath,
                bool bWatch, bool& bExist);

    /**
     * Determine whether any listeners set on specified node
     *
     * @param sPath node's path
     * @return true if has listeners
     */
    bool hasListeners(const std::string& sPath);

    /**
     * Remove specified zookeeper file
     *
     * @param sPath node's path
     * @return true if success
     */
    bool remove(const std::string& sPath);

    /**
     * Read data from zookeeper file
     *
     * @param sPath node's path
     * @param sData contains file data
     * @param bWatch if true, set data change on the file 
     * @return true if success
     */
    bool readData(const std::string& sPath,
                  std::string& sData, bool bWatch);
    
    /**
     * Write data to zookeeper file
     *
     * @param sPath node's path
     * @param sData file data to write
     * @return true if success
     */
    bool writeData(const std::string& sPath, 
                   const std::string& sData);

private:
    bool watchForChilds(const std::string& sPath,
                        std::vector<std::string>& children);
    bool watchForData(const std::string& sPath);
    watcherid_t addHandler(const std::string& sPath, 
                           ListenersMap& map, 
                           EventHandler* pHandler);
    bool removeHandler(const std::string& sPath, 
                       ListenersMap& map, 
                       watcherid_t wid);
    bool getChildren(const std::string& sPath, bool bWatch,
                     std::vector<std::string>& children);
    bool hasListeners(const std::string& sPath,
                      const ListenersMap& map);

    /**
     * Return children of specified zk file path
     * 
     * @param sPath zk file path
     * @param children the children
     * @param bWatch set watch if true
     */
    bool getChildren(const std::string& sPath,
                     std::vector<std::string>& children,
                     bool watch = false);
    bool createNode(const std::string& sPath,
                    const std::string &value,
                    bool bPermanent = false);

    bool createNodeSequential(const std::string& sPath,
                              const std::string& sData,
                              bool bPermanent,
                              std::string& sResultPath);
    bool createParentPath(const std::string& sPath);

    void handleEvent(int type, int state, const char* path);

private:
    static void watcherEvent(zhandle_t *, int type, int state,
                             const char *path,void*context);

    static state_t fromZkState(int state);
    static event_t fromZkEvent(int event);

    int getState() const;

private:
    /// zookeeper handle
    zhandle_t* m_pZkHandle;

    /// zookeeper host name
    std::string m_sHost;
    
    /// Receive timeout value
    int32_t m_nRecvTimeout;

    /// Handlers for children change event
    ListenersMap m_childListener;

    /// Handlers for data change event
    ListenersMap m_dataListener;

    /// read/write lock for handler maps
    FX_NS(thread)::RWLock m_rwLock;
    
    /// lock for closing 
    FX_NS(thread)::FastMutex m_closingMutex;

    /// watch id counter
    std::atomic_long m_watchCounter;

private:
    DECLARE_LOGGER();
};

/////////////////////////////////////////
///
inline int ZkClientWrapper::getState() const 
{
    if(!m_pZkHandle) 
    {
        return ZOO_EXPIRED_SESSION_STATE;
    }
    return zoo_state(m_pZkHandle);
}

inline bool ZkClientWrapper::isConnected() const 
{
    return (ZOO_CONNECTED_STATE == getState());
}

inline bool ZkClientWrapper::isConnecting() const 
{
    int stat = getState();
    return (ZOO_CONNECTING_STATE == stat 
            || ZOO_ASSOCIATING_STATE == stat);
}

inline bool ZkClientWrapper::isBad() const 
{
    int stat = getState();
    return (ZOO_EXPIRED_SESSION_STATE == stat
            || ZOO_AUTH_FAILED_STATE == stat);
}

//static 
inline ZkClientWrapper::state_t ZkClientWrapper::fromZkState(int state)
{
    if (ZOO_EXPIRED_SESSION_STATE == state)
    {
        return ZK_EXPIRED_SESSION_STATE;
    }
    if (ZOO_AUTH_FAILED_STATE == state)
    {
        return ZK_AUTH_FAILED_STATE;
    }
    if (ZOO_CONNECTING_STATE == state)
    {
        return ZK_CONNECTING_STATE;
    }
    if (ZOO_ASSOCIATING_STATE == state)
    {
        return ZK_ASSOCIATING_STATE;
    }
    if (ZOO_CONNECTED_STATE == state)
    {
        return ZK_CONNECTED_STATE;
    }
    return ZK_INVALID_STATE;
}

//static 
inline ZkClientWrapper::event_t ZkClientWrapper::fromZkEvent(int event)
{
    if (ZOO_CREATED_EVENT == event)
    {
        return ZK_CREATED_EVENT;
    }
    if (ZOO_DELETED_EVENT == event)
    {
        return ZK_DELETED_EVENT;
    }
    if (ZOO_CHANGED_EVENT == event)
    {
        return ZK_CHANGED_EVENT;
    }
    if (ZOO_CHILD_EVENT == event)
    {
        return ZK_CHILD_EVENT;
    }
    if (ZOO_SESSION_EVENT == event)
    {
        return ZK_SESSION_EVENT;
    }
    if (ZOO_NOTWATCHING_EVENT == event)
    {
        return ZK_NOTWATCHING_EVENT;
    }
    return ZK_INVALID_EVENT;
}

FX_NS_END

#endif //__FX_ZKCLIENTWRAPPER_H
